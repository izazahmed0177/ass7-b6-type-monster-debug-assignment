<!--  Bonus Problem 2 solve -->
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Blog</title>

    <!-- google font -->

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;500&display=swap" rel="stylesheet">

    <!-- CSS only -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.2.0/dist/css/bootstrap.min.css" rel="stylesheet"
        integrity="sha384-gH2yIJqKdNHPEq0n4Mqa/HGKIhSkIHeL5AyhkYV8i59U5AR6csBvApHHNl/vI1Bx" crossorigin="anonymous">

    <!-- fontawesome -->
    <script src="https://kit.fontawesome.com/4425165926.js" crossorigin="anonymous"></script>

    <link rel="stylesheet" href="styles.css">
</head>

<body>

    <header class="m-4">

        <h1 class="text-center text-white">Blog</h1>

    </header>


    <main>
        <!-- Q 1 -->
        <section class="m-5">
            <div class="container text-bg-light p-5">
                <h2>1.What is the difference between local storage and session storage in browser ?</h2>

                <p>
                    <span class="fw-bold">Local storage</span> is the most recent mechanism. It allows for larger
                    amounts of data to be stored, but the data is not deleted when the browser is closed. Local storage
                    is useful for storing data that the user will need to access later, such as offline data.
                </p>
                <p>
                    <span class="fw-bold"> Session storage</span> is similar to cookies, but the data is only stored for
                    the current session. This means that the data will be deleted when the user closes the browser.
                    Session storage is useful for storing data that is sensitive, such as login credentials.
                </p>
                <div>
                    <h4>Local Storage</h4>
                    <p>
                        Most web applications these days require some type of user input, whether it be for a username,
                        shipping address, or even just a preferences setting. This input is then usually sent off to a
                        server somewhere to be processed and stored. However, what if your application needs to store
                        data locally on the user's computer? This is where Local Storage comes in.
                        <br>
                        Local Storage is a type of web storage that allows JavaScript to store and access data right in
                        the browser. This is especially useful for storing data that you want to persist even if the
                        user closes the browser, such as preferences or settings.
                        <br>
                        The data in Local Storage is stored in key/value pairs. The key is like the name of the data,
                        and the value is like the actual data itself. You can think of it as a variable in JavaScript.
                        To store data in Local Storage, you first need to create a key. Then you can store any data you
                        want under that key.
                        <br>
                        To create a key, you use the setItem() method. This method takes two arguments, the first is the
                        key, and the second is the value you want to store.
                    </p>
                    <div class="text-success">
                        localStorage.setItem('key', 'value');
                    </div>
                    <p>
                        Now that you have a key, you can store any data you want under that key. The data you store can
                        be any data type that JavaScript supports, including strings, numbers, objects, and arrays.

                        To store data, you use the setItem() method again. This time, you pass in the key as the first
                        argument and the data you want to store as the second argument.
                    </p>
                    <div class="text-success">
                        localStorage.setItem('key', 'value');
                    </div>

                    <p>
                        To retrieve data from Local Storage, you use the getItem() method. This method takes the key as
                        an argument and returns the data that is stored under that key.
                    </p>
                    <div class="text-success">
                        localStorage.getItem('key');
                    </div>
                    <p>
                        If you want to remove an item from Local Storage, you use the removeItem() method. This method
                        takes the key as an argument and removes the data that is stored under that key.
                    </p>
                    <div class="text-success">
                        localStorage.removeItem('key');
                    </div>
                </div>

                <div>
                    <h4>Session Storage</h4>
                    <p>
                        Session Storage is a type of web storage that allows web applications to store data locally
                        within the user's browser. Unlike cookies, data stored in session storage is specific to the
                        site on which it was created and data is not shared with other sites.
                        <br>
                        Session Storage is a new feature introduced in HTML5 that allows you to store data locally in
                        the user's browser. Unlike cookies, data stored in session storage is specific to the site on
                        which it was created and data is not shared with other sites.

                        Session Storage is a way of storing data on the client side of an application. It's similar to
                        local storage, but with a few key differences -
                        <br>
                        1. Session Storage data is only available to the site that created it.
                        <br>
                        2. Session Storage data is not shared with other sites.
                        <br>
                        3. Session Storage data is not persistent, meaning it is only available for the duration of the
                        user's session on a site.
                        <br>
                        4. Session Storage data is specific to the browser tab in which it was created.
                        <br>
                        Session Storage is a great way to improve the performance of your web applications by reducing
                        the amount of data that needs to be transferred between the client and server. It can also be
                        used to store data in a more secure way since the data is not stored in cookies where it can be
                        accessed by third-party sites.
                        <br>
                        To use Session Storage in your web applications, you'll need to use the sessionStorage object.
                        This object provides access to the current session's storage.
                        <br>
                        The sessionStorage object has two methods
                        <br>
                        setItem() - This method sets a key/value pair in the session storage.
                        <br>
                    </p>
                    <div class="text-success">
                        sessionStorage.setItem("name", "tutorialsPoint");
                    </div>
                    <p>
                        getItem() - This method retrieves the value of a key from the session storage.
                    </p>
                    <div class="text-success">
                        var name = sessionStorage.getItem("name");
                    </div>
                    <p>

                        The sessionStorage object also has a couple of other properties -
                        <br>
                        1. length - This property returns the number of key/value pairs in the session storage.
                        <br>
                        2. key() - This method accepts an index as a parameter and returns the key at that index in the
                        session storage
                        <br>
                        Session Storage is a great way to improve the performance of your web applications and store
                        data in a more secure way.
                    </p>
                </div>


            </div>
        </section>
        <!--Q 2 -->
        <section class="m-5">
            <div class="container text-bg-light p-5">
                <h2>2.What is the difference between global scope and block scope?</h2>
                <div>
                    <h4>Global Scope</h4>
                    <p>
                        Variables defined outside any function, block, or module scope have global scope. Variables in
                        global scope can be accessed from everywhere in the application.
                        <br>
                        When a module system is enabled it's harder to make global variables, but one can still do it.
                        By defining a variable in HTML, outside any function, a global variable can be created:
                    </p>
                    <div class="text-success">
                        script
                        <br>
                        let GLOBAL_DATA = { value : 1};
                        <br>
                        script
                        <br>
                        console.log(GLOBAL_DATA);
                    </div>
                    <p>
                        When there is no module system in place, it is a lot easier to create global variables. A
                        variable declared outside any function, in any file, is a global variable.
                        <br>
                        Global variables are available for the lifetime of the application.
                        <br>
                        Another way for creating a global variable is to use the window global object anywhere in the
                        application:
                    </p>

                    <div class="text-success">
                        window.GLOBAL_DATA = { value: 1 };
                    </div>
                    <p>At this point, the GLOBAL_DATA variable is visible everywhere.</p>
                    <div class="text-success">
                        console.log(GLOBAL_DATA)
                    </div>
                    <p>Please note that variables declared inside a function without var keyword also become global
                        variables.</p>

                </div>

                <div>
                    <h4>Block Scope</h4>
                    <p>
                        Block scope is defined with curly braces. It is separated by { and }.
                        <br>
                        Variables declared with let and const can have block scope. They can only be accessed in the
                        block in which they are defined.
                        <br>
                        Consider the next code that emphasizes let block scope:
                    </p>
                    <div class="text-success">
                        let x = 1;
                        <br>
                        {
                        <br>
                        let x = 2;
                        <br>
                        }
                        <br>
                        console.log(x); //1
                    </div>
                    <p>In contrast, the var declaration has no block scope:</p>
                    <div class="text-success">
                        var x = 1;
                        <br>
                        {
                        <br>
                        var x = 2;
                        <br>
                        }
                        <br>
                        console.log(x); //2
                    </div>
                    <p>
                        Another common problem with not having block scope is the use of an asynchronous operation like
                        setTimeout() in a loop. The flowing loop code displays the number 5, five times.
                    </p>
                    <div class="text-success">
                        (function run(){
                        <br>
                        for(var i=0; i<5; i++){ <br>
                            setTimeout(function logValue(){
                            <br>
                            console.log(i); //5
                            <br>
                            }, 100);
                            <br>
                            }
                            <br>
                            })();
                    </div>
                    <p>
                        The for loop statement, with the let declaration, creates a new variable locale to the block
                        scope, for each iteration. The next loop code shows 0 1 2 3 4 5.
                    </p>

                    <div class="text-success">
                        (function run(){
                        <br>
                        for(let i=0; i<5; i++){ <br>
                            setTimeout(function log(){
                            <br>
                            console.log(i); //0 1 2 3 4
                            <br>
                            }, 100);
                            <br>
                            }
                            <br>
                            })();
                    </div>



                </div>

                <p class="fw-bold">
                    Variables defined in global scope are available everywhere in the application.
                    <br>
                    In a module, a variable declared outside any function is hidden and not available to other modules
                    unless it is explicitly exported.
                    <br>
                    Function scope means that parameters and variables defined in a function are visible everywhere
                    within the function
                    <br>
                    Variables declared with let and const have block scope. var doesn’t have block scope.
                </p>



            </div>
        </section>
        <!-- Q 3 -->
        <section class="m-5">
            <div class="container text-bg-light p-5">
                <h2>3.How to work javascript event loop?</h2>
                <p>

                    We often hear that JavaScript is a single-threaded programming language, which means it executes all
                    of the instructions line by line in a synchronous manner. Thus since everything works on the main
                    thread, there seems to be no possibility of executing parallel processes in JavaScript.
                    <br>
                    But now let's assume that we have a function which is taking some time to execute, for example in
                    the below function which is having a loop over 10k times, the console.log() would be executed once
                    the loop is over and in the meantime, our UI interaction with the browser would be interrupted.
                </p>

                <div class="text-success">
                    function someTimeTakingFunc() {
                    <br>
                    for(var i = 0; i < 10000; i++) { <br>

                        }
                        <br>
                        console.log("Loop has been executed")
                        }
                </div>
                <p>
                    The above scenario seems to be impractical, but there might be cases where any function can take an
                    indeterminate amount of time and our main thread would be blocked, for example calling an API for
                    fetching data from the server-side. And this is the practical use case we are dealing with in
                    development every day. So how JavaScript handles this and where does the event loop come into the
                    picture? We will surely get to know this, but before moving further, let's understand the basic
                    memory architecture in JavaScript.
                </p>
                <h4>Memory Organization of JavaScript:</h4>
                <p>
                    The Javascript Engine consists of two main components:
                    <br>

                    1. Memory Heap — this is where the memory allocation happens, all of our object variables are
                    assigned
                    here in a random manner.
                    <br>
                    2. Call Stack — this is where your function calls are stored.
                </p>
                <h4>Javascript Web APIs</h4>
                <p>
                    These are the additional functionality, that helps us perform some additional tasks which cannot be
                    run using the main thread. However, since our JavaScript runtime is single-threaded, it can export
                    some tasks to the WEB APIs which helps us to respond to multiple threads. Example of some web APIs
                    are:
                    <br>
                    1. DOM <br>
                    2. Ajax (Network requests) <br>
                    3. setTimeout() <br>
                    For instance, setTimeout() is called, the browser delegates the task to a different thread to
                    calculate the time interval specified in the argument of the setTimeout() method, and once done this
                    tread would then call the desired function in callback stack.
                    <br>
                    Since JavaScript is single-threaded, the browser has the capability of delegating the task in
                    multiple threads. But how does the event loop help in these executions? But now we are good to go
                    ahead with Event Loop.
                </p>

                <h4>Event Loop</h4>
                <p>
                    Since we know that Web APIs delegate some of the tasks to different threads, on completion of these
                    tasks, how the main or desired functions are sent to the call stack.
                    <br>
                    Event Queue is a special queue, which keeps track of all the functions queues, which are needed to
                    be pushed into the call stack. The event queue is responsible for sending new functions to the track
                    for processing. The queue data structure is required to maintain the correct sequence in which all
                    operations should be sent for execution.
                    <br>
                    Let's take an example, in the following example, we are using a setTimeout function, which will log
                    the "executed" string after 2000 milliseconds.
                </p>

                <div class="text-success">
                    setTimeout(function(){
                    <br>
                    console.log("Executed";)
                    <br>
                    }, 2000);
                </div>

                <p>
                    Now when a setTimeout operation is processed in the call stack. On its execution, it calls a web API
                    which fires a timer for 2000 milliseconds. After 2000 milliseconds has been elapsed, the web API,
                    place the callback function of setTimeout in the event queue.
                    <br>
                    Here need to mention that, just placing our function does not necessarily imply that the function
                    will get executed. This function has to be pushed into the call stack for execution and here the
                    event loop comes into the picture. The event loop waits for the function stack to be empty, once the
                    call stack is empty this will push the first function from the event queue to the call stack, and in
                    this way, the desired function will be called.
                </p>
                <p>
                    Thus event loop works in a cyclic manner, where it continually checks whether or not the call stack
                    is empty. If it is empty, new functions are added from the event queue. If it is not, then the
                    current function call is processed.
                </p>
            </div>
        </section>
        <!-- Q 4 -->
        <section class="m-5 ">
            <div class="container text-bg-light p-5">
                <h2>4. How do I get undefined in JavaScript? ?</h2>

                <div>

                    <p>
                        JavaScript interpreter returns undefined when accessing a variable or object property that is
                        not yet initialized. For example:
                    </p>
                    <div class="text-success">
                        let company;
                        <br>
                        company; // => undefined <br>
                        let person = { name: 'John Smith' }; <br>
                        person.age; // => undefined
                    </div>
                    <p>
                        JavaScript is permissive, developers have the temptation to access uninitialized values. I'm
                        guilty of such bad practice too.
                        <br>
                        Often such risky actions generate undefined related errors:
                        <br>
                        1. TypeError: 'undefined' is not a function <br>
                        2. TypeError: Cannot read property 'prop-name' of undefined
                        and alike type errors.
                        <br>
                        JavaScript developer can understand the irony of this joke:
                    </p>

                    <div class="text-success">
                        function undefined() { <br>
                        // problem solved
                        <br>
                        }
                    </div>
                    <p>To reduce such errors, you have to understand the cases when undefined is generated. Let's
                        explore undefined and its effect on code safety.</p>

                    <p>
                        Undefined value primitive value is used when a variable has not been assigned a value.
                    </p>
                    <p>
                        The standard clearly defines that you will receive undefined when accessing uninitialized
                        variables, non-existing object properties, non-existing array elements, and alike.
                        <br>
                        A few examples:
                    </p>

                    <div class="text-success">
                        let number; <br>
                        number; // => undefined <br>
                        let movie = { name: 'Interstellar' }; <br>
                        movie.year; // => undefined <br>
                        let movies = ['Interstellar', 'Alexander']; <br>
                        movies[3]; // => undefined
                    </div>
                    <p>
                        The above example demonstrates that accessing:

                        1. an uninitialized variable number <br>
                        2. a non-existing object property movie.year <br>
                        3. or a non-existing array element movies[3] <br>
                        are evaluated to undefined.
                    </p>
                    <p>Undefined type is a type whose sole value is the undefined value.</p>
                    <div class="text-success">
                        let nothing; <br>
                        typeof nothing === 'undefined'; // => true
                    </div>

                    <p>A declared variable but not yet assigned with a value (uninitialized) is by default undefined.
                    </p>

                    <div class="text-success">
                        let myVariable; <br>
                        myVariable; // => undefined
                    </div>
                    <p>When accessing a non-existing object property, JavaScript returns undefined.</p>
                    <div class="text-success">
                        let favoriteMovie = { <br>
                        title: 'Blade Runner' <br>
                        }; <br>
                        favoriteMovie.actors; // => undefined
                    </div>

                    <p>The function parameters implicitly default to undefined.</p>

                    <div class="text-success">
                        function multiply(a, b) { <br>
                        a; // => 5 <br>
                        b; // => undefined <br>
                        return a * b; <br>
                        } <br>
                        multiply(5); // => NaN
                    </div>
                    <p>The invocation multiply(5) is performed with a single argument: as result a parameter is 5, but
                        the b parameter is undefined.</p>

                    <p>Implicitly, without return statement, a JavaScript function returns undefined.</p>

                    <div class="text-success">
                        function square(x) { <br>
                        const res = x * x; <br>
                        } <br>
                        square(2); // => undefined
                    </div>
                    <p>
                        What it does mean inside a function to have return; statement? The function returns undefined.
                        If you don't know in detail the mechanism of ASI, the unexpectedly returned undefined is
                        misleading.
                        <br>
                        For instance, let's study the returned value of getPrimeNumbers() invocation:
                    </p>
                    <div class="text-success">
                        function getPrimeNumbers() { <br>
                        return <br>
                        [ 2, 3, 5, 7, 11, 13, 17 ] <br>
                        } <br>
                        getPrimeNumbers() // => undefined
                    </div>
                    <p>
                        void 'expression' evaluates the expression and returns undefined no matter the result of the
                        evaluation.
                    </p>
                    <div class="text-success">
                        void 1; // => undefined <br>
                        void (false); // => undefined <br>
                        void {name: 'John Smith'}; // => undefined <br>
                        void Math.min(1, 3); // => undefined
                    </div>
                    <p>One use case of void operator is to suppress expression evaluation to undefined, relying on some
                        side-effect of the evaluation.</p>

                    <p>You get undefined when accessing an array element with an out of bounds index.</p>
                    <div class="text-success">
                        const colors = ['blue', 'white', 'red']; <br>
                        colors[5]; // => undefined <br>
                        colors[-1]; // => undefined
                    </div>
                    <p>
                        colors array has 3 elements, thus valid indexes are 0, 1, and 2.
                        <br>
                        Because there are no array elements at indexes 5 and -1, the accessors colors[5] and colors[-1]
                        are undefined.
                    </p>

                    <p>
                        undefined existence is a consequence of JavaScript's permissive nature that allows the usage of:
                        <br>
                        1. uninitialized variables <br>
                        2. non-existing object properties or methods <br>
                        3. out of bounds indexes to access array elements <br>
                        4.the invocation result of a function that returns nothing
                        <br>
                        Comparing directly against undefined is unsafe because you rely on a permitted but discouraged
                        practice mentioned above.
                    </p>

                </div>


            </div>
        </section>


    </main>
    <footer class="text-center text-white p-4">
        <p>Copyright 2022 Izaz Blog </p>
    </footer>

</body>

</html>